package controllers;

import javafx.application.Platform;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.*;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import models.Admin;
import catalogs.RouteCatalog;
import database.DatabaseConnection;
import config.DatabaseConfig;

import java.io.IOException;
import java.sql.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class AdminReportsController {

    private String currentUsername;
    private Admin currentAdmin;
    private RouteCatalog routeCatalog;

    @FXML private Text welcomeTitle;
    @FXML private Text userGreeting;
    
    @FXML private TextArea reportArea;
    
    @FXML private Button generateBookingReportButton;
    @FXML private Button generateRevenueReportButton;
    @FXML private Button generateRouteReportButton;
    @FXML private Button exportReportButton;
    @FXML private Button backButton;

    public static void show(Stage stage, String username, Admin admin) {
        try {
            FXMLLoader loader = new FXMLLoader(AdminReportsController.class.getResource("/ui/admin-reports.fxml"));
            Parent root = loader.load();
            
            AdminReportsController controller = loader.getController();
            controller.setAdminData(username, admin);
            
            Scene scene = new Scene(root, 1200, 800);
            scene.getStylesheets().add(AdminReportsController.class.getResource("/ui/admin-reports.css").toExternalForm());
            
            stage.setScene(scene);
            stage.setTitle("TicketGenie - Reports");
            stage.centerOnScreen();
            
        } catch (IOException e) {
            e.printStackTrace();
            showErrorAlert("Failed to load reports page: " + e.getMessage());
        }
    }

    public void setAdminData(String username, Admin admin) {
        this.currentUsername = username;
        this.currentAdmin = admin;
        this.routeCatalog = RouteCatalog.getInstance();
        
        if (userGreeting != null) {
            userGreeting.setText("Reports Dashboard - " + username);
        }
    }

    @FXML
    public void initialize() {
        System.out.println("AdminReportsController initialized");
        setupEventHandlers();
    }

    private void setupEventHandlers() {
        if (generateBookingReportButton != null) {
            generateBookingReportButton.setOnAction(e -> generateBookingReport());
        }
        if (generateRevenueReportButton != null) {
            generateRevenueReportButton.setOnAction(e -> generateRevenueReport());
        }
        if (generateRouteReportButton != null) {
            generateRouteReportButton.setOnAction(e -> generateRouteReport());
        }
        if (exportReportButton != null) {
            exportReportButton.setOnAction(e -> exportReport());
        }
        if (backButton != null) {
            backButton.setOnAction(e -> handleBack());
        }
    }

    private void generateBookingReport() {
        try {
            StringBuilder report = new StringBuilder();
            report.append("=== BOOKING STATISTICS REPORT ===\n\n");
            report.append("Report Generated: ").append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))).append("\n");
            report.append("Generated By: ").append(currentUsername).append("\n\n");
            
            // Get real data from database
            Map<String, Object> bookingStats = getBookingStatisticsFromDB();
            List<Map<String, Object>> popularRoutes = getPopularRoutesFromDB();
            List<Map<String, Object>> recentBookings = getRecentBookingsFromDB();
            
            report.append("ğŸ“Š OVERALL BOOKING STATISTICS\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            report.append("Total Bookings: ").append(bookingStats.get("totalBookings")).append("\n");
            report.append("Confirmed Bookings: ").append(bookingStats.get("confirmedBookings")).append("\n");
            report.append("Cancelled Bookings: ").append(bookingStats.get("cancelledBookings")).append("\n");
            report.append("Pending Bookings: ").append(bookingStats.get("pendingBookings")).append("\n\n");
            
            report.append("ğŸ“ˆ TIME-BASED BOOKINGS\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            report.append("Today: ").append(bookingStats.get("todayBookings")).append(" bookings\n");
            report.append("This Week: ").append(bookingStats.get("weekBookings")).append(" bookings\n");
            report.append("This Month: ").append(bookingStats.get("monthBookings")).append(" bookings\n\n");
            
            report.append("ğŸ† TOP 5 POPULAR ROUTES\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            if (popularRoutes.isEmpty()) {
                report.append("No booking data available\n\n");
            } else {
                for (int i = 0; i < Math.min(popularRoutes.size(), 5); i++) {
                    Map<String, Object> route = popularRoutes.get(i);
                    report.append(i + 1).append(". ").append(route.get("route")).append(": ")
                          .append(route.get("bookings")).append(" bookings\n");
                }
                report.append("\n");
            }
            
            report.append("ğŸ“‹ RECENT BOOKINGS (Last 10)\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            if (recentBookings.isEmpty()) {
                report.append("No recent bookings\n\n");
            } else {
                for (Map<String, Object> booking : recentBookings) {
                    report.append("â€¢ ").append(booking.get("bookingId")).append(" - ")
                          .append(booking.get("customerName")).append(" - ")
                          .append(booking.get("route")).append(" - ")
                          .append(booking.get("date")).append("\n");
                }
                report.append("\n");
            }
            
            report.append("ğŸ“Š CANCELLATION ANALYSIS\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            int total = (int) bookingStats.get("totalBookings");
            int cancelled = (int) bookingStats.get("cancelledBookings");
            double cancellationRate = total > 0 ? (cancelled * 100.0 / total) : 0;
            report.append("Cancellation Rate: ").append(String.format("%.1f", cancellationRate)).append("%\n");
            report.append("Confirmation Rate: ").append(String.format("%.1f", 100 - cancellationRate)).append("%\n\n");
            
            report.append("ğŸ’¡ RECOMMENDATIONS\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            report.append("â€¢ Consider adding more schedules for high-demand routes\n");
            report.append("â€¢ Analyze cancellation reasons to improve service\n");
            report.append("â€¢ Monitor booking trends for capacity planning\n");
            
            reportArea.setText(report.toString());
            showSuccess("Booking report generated successfully");
            
        } catch (Exception e) {
            showError("Failed to generate booking report: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void generateRevenueReport() {
        try {
            StringBuilder report = new StringBuilder();
            report.append("=== REVENUE ANALYSIS REPORT ===\n\n");
            report.append("Report Generated: ").append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))).append("\n");
            report.append("Generated By: ").append(currentUsername).append("\n\n");
            
            Map<String, Object> revenueOverview = getRevenueOverviewFromDB();
            List<Map<String, Object>> revenueByRoute = getRevenueByRouteFromDB();
            List<Map<String, Object>> revenueByPeriod = getRevenueByPeriodFromDB();
            
            report.append("ğŸ’° REVENUE OVERVIEW\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            report.append("Total Revenue: PKR ").append(formatCurrency((double) revenueOverview.get("totalRevenue"))).append("\n");
            report.append("Average Booking Value: PKR ").append(formatCurrency((double) revenueOverview.get("averageValue"))).append("\n");
            report.append("Refunds Issued: PKR ").append(formatCurrency((double) revenueOverview.get("refunds"))).append("\n");
            report.append("Net Revenue: PKR ").append(formatCurrency((double) revenueOverview.get("netRevenue"))).append("\n\n");
            
            report.append("ğŸ“… REVENUE BY PERIOD\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            report.append("Today: PKR ").append(formatCurrency((double) revenueOverview.get("todayRevenue"))).append("\n");
            report.append("This Week: PKR ").append(formatCurrency((double) revenueOverview.get("weekRevenue"))).append("\n");
            report.append("This Month: PKR ").append(formatCurrency((double) revenueOverview.get("monthRevenue"))).append("\n\n");
            
            report.append("ğŸšŒ TOP 5 REVENUE-GENERATING ROUTES\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            if (revenueByRoute.isEmpty()) {
                report.append("No revenue data available\n\n");
            } else {
                for (int i = 0; i < Math.min(revenueByRoute.size(), 5); i++) {
                    Map<String, Object> routeRevenue = revenueByRoute.get(i);
                    report.append(i + 1).append(". ").append(routeRevenue.get("route")).append(": PKR ")
                          .append(formatCurrency((double) routeRevenue.get("revenue"))).append("\n");
                }
                report.append("\n");
            }
            
            report.append("ğŸ“ˆ REVENUE TREND (Last 7 Days)\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            if (revenueByPeriod.isEmpty()) {
                report.append("No revenue trend data available\n\n");
            } else {
                for (Map<String, Object> period : revenueByPeriod) {
                    report.append(period.get("period")).append(": PKR ")
                          .append(formatCurrency((double) period.get("revenue"))).append("\n");
                }
                report.append("\n");
            }
            
            report.append("ğŸ’¡ INSIGHTS\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            report.append("â€¢ Identify highest revenue-generating routes\n");
            report.append("â€¢ Monitor revenue trends for seasonality\n");
            report.append("â€¢ Optimize pricing for underperforming routes\n");
            
            reportArea.setText(report.toString());
            showSuccess("Revenue report generated successfully");
            
        } catch (Exception e) {
            showError("Failed to generate revenue report: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private void generateRouteReport() {
        try {
            List<Map<String, Object>> routePerformance = getRoutePerformanceFromDB();
            Map<String, Object> routeMetrics = getRouteMetricsFromDB();
            
            StringBuilder report = new StringBuilder();
            report.append("=== ROUTE PERFORMANCE REPORT ===\n\n");
            report.append("Report Generated: ").append(LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"))).append("\n");
            report.append("Generated By: ").append(currentUsername).append("\n\n");
            
            report.append("ğŸ“Š ROUTE OVERVIEW\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            report.append("Total Active Routes: ").append(routeMetrics.get("totalRoutes")).append("\n");
            report.append("Total Schedules: ").append(routeMetrics.get("totalSchedules")).append("\n");
            report.append("Average Occupancy Rate: ").append(routeMetrics.get("avgOccupancy")).append("%\n");
            report.append("Total Revenue: PKR ").append(formatCurrency((double) routeMetrics.get("totalRevenue"))).append("\n\n");
            
            report.append("ğŸ† TOP PERFORMING ROUTES\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n\n");
            
            if (routePerformance.isEmpty()) {
                report.append("No route performance data available\n\n");
            } else {
                for (int i = 0; i < Math.min(routePerformance.size(), 5); i++) {
                    Map<String, Object> route = routePerformance.get(i);
                    double occupancyRate = (double) route.get("occupancyRate");
                    String performance = getPerformanceStars(occupancyRate);
                    report.append(getRankEmoji(i + 1)).append(" ").append(route.get("route")).append("\n");
                    report.append("   Base Price: PKR ").append(formatCurrency((double) route.get("basePrice"))).append("\n");
                    report.append("   Total Bookings: ").append(route.get("bookings")).append("\n");
                    report.append("   Occupancy Rate: ").append(String.format("%.1f", occupancyRate)).append("%\n");
                    report.append("   Revenue: PKR ").append(formatCurrency((double) route.get("revenue"))).append("\n");
                    report.append("   Performance: ").append(performance).append("\n\n");
                }
            }
            
            report.append("ğŸ“ˆ PERFORMANCE METRICS\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            report.append("Average Bookings per Route: ").append(String.format("%.1f", (double) routeMetrics.get("avgBookings"))).append("\n");
            report.append("Highest Occupancy: ").append(routeMetrics.get("maxOccupancy")).append("%\n");
            report.append("Lowest Occupancy: ").append(routeMetrics.get("minOccupancy")).append("%\n");
            report.append("Most Popular Class: ").append(routeMetrics.get("popularClass")).append("\n\n");
            
            report.append("ğŸ’¡ RECOMMENDATIONS\n");
            report.append("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
            report.append("â€¢ Increase frequency for high-demand routes\n");
            report.append("â€¢ Review pricing for underperforming routes\n");
            report.append("â€¢ Consider discontinuing routes with <50% occupancy\n");
            report.append("â€¢ Promote business class on profitable routes");
            
            reportArea.setText(report.toString());
            showSuccess("Route report generated successfully");
            
        } catch (Exception e) {
            showError("Failed to generate route report: " + e.getMessage());
            e.printStackTrace();
        }
    }

    // ==================== DATABASE QUERY METHODS ====================

    private Map<String, Object> getBookingStatisticsFromDB() throws SQLException {
        Map<String, Object> stats = new HashMap<>();
        
        try (Connection conn = DriverManager.getConnection(DatabaseConfig.getDbUrl(), 
                                                         DatabaseConfig.getDbUser(), 
                                                         DatabaseConfig.getDbPassword())) {
            
            // Total bookings
            String totalQuery = "SELECT COUNT(*) as total FROM Booking";
            try (PreparedStatement stmt = conn.prepareStatement(totalQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    stats.put("totalBookings", rs.getInt("total"));
                }
            }
            
            // Bookings by status
            String statusQuery = "SELECT Status, COUNT(*) as count FROM Booking GROUP BY Status";
            try (PreparedStatement stmt = conn.prepareStatement(statusQuery);
                 ResultSet rs = stmt.executeQuery()) {
                int confirmed = 0, cancelled = 0, pending = 0;
                while (rs.next()) {
                    String status = rs.getString("Status");
                    int count = rs.getInt("count");
                    switch (status != null ? status.toLowerCase() : "") {
                        case "confirmed": confirmed = count; break;
                        case "cancelled": cancelled = count; break;
                        case "pending": pending = count; break;
                        default: confirmed = count; break;
                    }
                }
                stats.put("confirmedBookings", confirmed);
                stats.put("cancelledBookings", cancelled);
                stats.put("pendingBookings", pending);
            }
            
            // Today's bookings
            String today = LocalDate.now().toString();
            String todayQuery = "SELECT COUNT(*) as count FROM Booking " +
                               "WHERE CAST(BookingDateTime AS DATE) = ?";
            try (PreparedStatement stmt = conn.prepareStatement(todayQuery)) {
                stmt.setString(1, today);
                try (ResultSet rs = stmt.executeQuery()) {
                    if (rs.next()) {
                        stats.put("todayBookings", rs.getInt("count"));
                    }
                }
            }
            
            // This week's bookings
            String weekQuery = "SELECT COUNT(*) as count FROM Booking " +
                              "WHERE BookingDateTime >= DATEADD(day, -7, GETDATE())";
            try (PreparedStatement stmt = conn.prepareStatement(weekQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    stats.put("weekBookings", rs.getInt("count"));
                }
            }
            
            // This month's bookings
            String monthQuery = "SELECT COUNT(*) as count FROM Booking " +
                               "WHERE BookingDateTime >= DATEADD(month, -1, GETDATE())";
            try (PreparedStatement stmt = conn.prepareStatement(monthQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    stats.put("monthBookings", rs.getInt("count"));
                }
            }
        }
        
        return stats;
    }
    
    private List<Map<String, Object>> getPopularRoutesFromDB() throws SQLException {
        List<Map<String, Object>> routes = new ArrayList<>();
        
        String query = 
            "SELECT TOP 5 " +
            "   r.Source + ' â†’ ' + r.Destination as route, " +
            "   COUNT(b.BookingID) as bookings " +
            "FROM Booking b " +
            "INNER JOIN Reservation res ON b.ReservationID = res.ReservationID " +
            "INNER JOIN Route r ON res.RouteID = r.RouteID " +
            "WHERE b.Status != 'Cancelled' " +
            "GROUP BY r.Source, r.Destination " +
            "ORDER BY bookings DESC";
        
        try (Connection conn = DriverManager.getConnection(DatabaseConfig.getDbUrl(), 
                                                         DatabaseConfig.getDbUser(), 
                                                         DatabaseConfig.getDbPassword());
             PreparedStatement stmt = conn.prepareStatement(query);
             ResultSet rs = stmt.executeQuery()) {
            
            while (rs.next()) {
                Map<String, Object> route = new HashMap<>();
                route.put("route", rs.getString("route"));
                route.put("bookings", rs.getInt("bookings"));
                routes.add(route);
            }
        }
        
        return routes;
    }
    
    private List<Map<String, Object>> getRecentBookingsFromDB() throws SQLException {
        List<Map<String, Object>> bookings = new ArrayList<>();
        
        String query = 
            "SELECT TOP 10 " +
            "   b.BookingID as bookingId, " +
            "   u.Name as customerName, " +
            "   r.Source + ' â†’ ' + r.Destination as route, " +
            "   FORMAT(b.BookingDateTime, 'yyyy-MM-dd') as bookingDate " +
            "FROM Booking b " +
            "INNER JOIN Users u ON b.CustomerID = u.UserID " +
            "INNER JOIN Reservation res ON b.ReservationID = res.ReservationID " +
            "INNER JOIN Route r ON res.RouteID = r.RouteID " +
            "WHERE b.Status != 'Cancelled' " +
            "ORDER BY b.BookingDateTime DESC";
        
        try (Connection conn = DriverManager.getConnection(DatabaseConfig.getDbUrl(), 
                                                         DatabaseConfig.getDbUser(), 
                                                         DatabaseConfig.getDbPassword());
             PreparedStatement stmt = conn.prepareStatement(query);
             ResultSet rs = stmt.executeQuery()) {
            
            while (rs.next()) {
                Map<String, Object> booking = new HashMap<>();
                booking.put("bookingId", rs.getString("bookingId"));
                booking.put("customerName", rs.getString("customerName"));
                booking.put("route", rs.getString("route"));
                booking.put("date", rs.getString("bookingDate"));
                bookings.add(booking);
            }
        }
        
        return bookings;
    }
    
    private Map<String, Object> getRevenueOverviewFromDB() throws SQLException {
        Map<String, Object> overview = new HashMap<>();
        
        try (Connection conn = DriverManager.getConnection(DatabaseConfig.getDbUrl(), 
                                                         DatabaseConfig.getDbUser(), 
                                                         DatabaseConfig.getDbPassword())) {
            
            // Total revenue from completed payments
            String totalQuery = 
                "SELECT COALESCE(SUM(p.Amount), 0) as totalRevenue, " +
                "       COALESCE(AVG(p.Amount), 0) as averageValue " +
                "FROM Payment p " +
                "INNER JOIN Booking b ON p.PaymentID = b.PaymentID " +
                "WHERE p.PaymentStatus = 'Completed' AND b.Status = 'Confirmed'";
            
            try (PreparedStatement stmt = conn.prepareStatement(totalQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    double totalRevenue = rs.getDouble("totalRevenue");
                    overview.put("totalRevenue", totalRevenue);
                    overview.put("averageValue", rs.getDouble("averageValue"));
                    overview.put("refunds", totalRevenue * 0.05); // Estimated
                    overview.put("netRevenue", totalRevenue * 0.95); // Estimated net
                }
            }
            
            // Today's revenue
            String todayQuery = 
                "SELECT COALESCE(SUM(p.Amount), 0) as todayRevenue " +
                "FROM Payment p " +
                "INNER JOIN Booking b ON p.PaymentID = b.PaymentID " +
                "WHERE p.PaymentStatus = 'Completed' AND b.Status = 'Confirmed' " +
                "AND CAST(p.PaymentDate AS DATE) = CAST(GETDATE() AS DATE)";
            
            try (PreparedStatement stmt = conn.prepareStatement(todayQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    overview.put("todayRevenue", rs.getDouble("todayRevenue"));
                }
            }
            
            // This week's revenue
            String weekQuery = 
                "SELECT COALESCE(SUM(p.Amount), 0) as weekRevenue " +
                "FROM Payment p " +
                "INNER JOIN Booking b ON p.PaymentID = b.PaymentID " +
                "WHERE p.PaymentStatus = 'Completed' AND b.Status = 'Confirmed' " +
                "AND p.PaymentDate >= DATEADD(day, -7, GETDATE())";
            
            try (PreparedStatement stmt = conn.prepareStatement(weekQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    overview.put("weekRevenue", rs.getDouble("weekRevenue"));
                }
            }
            
            // This month's revenue
            String monthQuery = 
                "SELECT COALESCE(SUM(p.Amount), 0) as monthRevenue " +
                "FROM Payment p " +
                "INNER JOIN Booking b ON p.PaymentID = b.PaymentID " +
                "WHERE p.PaymentStatus = 'Completed' AND b.Status = 'Confirmed' " +
                "AND p.PaymentDate >= DATEADD(month, -1, GETDATE())";
            
            try (PreparedStatement stmt = conn.prepareStatement(monthQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    overview.put("monthRevenue", rs.getDouble("monthRevenue"));
                }
            }
        }
        
        return overview;
    }
    
    private List<Map<String, Object>> getRevenueByRouteFromDB() throws SQLException {
        List<Map<String, Object>> revenues = new ArrayList<>();
        
        String query = 
            "SELECT TOP 5 " +
            "   r.Source + ' â†’ ' + r.Destination as route, " +
            "   COALESCE(SUM(p.Amount), 0) as revenue " +
            "FROM Payment p " +
            "INNER JOIN Booking b ON p.PaymentID = b.PaymentID " +
            "INNER JOIN Reservation res ON b.ReservationID = res.ReservationID " +
            "INNER JOIN Route r ON res.RouteID = r.RouteID " +
            "WHERE p.PaymentStatus = 'Completed' AND b.Status = 'Confirmed' " +
            "GROUP BY r.Source, r.Destination " +
            "ORDER BY revenue DESC";
        
        try (Connection conn = DriverManager.getConnection(DatabaseConfig.getDbUrl(), 
                                                         DatabaseConfig.getDbUser(), 
                                                         DatabaseConfig.getDbPassword());
             PreparedStatement stmt = conn.prepareStatement(query);
             ResultSet rs = stmt.executeQuery()) {
            
            while (rs.next()) {
                Map<String, Object> route = new HashMap<>();
                route.put("route", rs.getString("route"));
                route.put("revenue", rs.getDouble("revenue"));
                revenues.add(route);
            }
        }
        
        return revenues;
    }
    
    private List<Map<String, Object>> getRevenueByPeriodFromDB() throws SQLException {
        List<Map<String, Object>> revenues = new ArrayList<>();
        
        String query = 
            "SELECT " +
            "   CONVERT(VARCHAR(10), p.PaymentDate, 120) as period, " +
            "   COALESCE(SUM(p.Amount), 0) as revenue " +
            "FROM Payment p " +
            "INNER JOIN Booking b ON p.PaymentID = b.PaymentID " +
            "WHERE p.PaymentStatus = 'Completed' AND b.Status = 'Confirmed' " +
            "   AND p.PaymentDate >= DATEADD(day, -7, GETDATE()) " +
            "GROUP BY CONVERT(VARCHAR(10), p.PaymentDate, 120) " +
            "ORDER BY period DESC";
        
        try (Connection conn = DriverManager.getConnection(DatabaseConfig.getDbUrl(), 
                                                         DatabaseConfig.getDbUser(), 
                                                         DatabaseConfig.getDbPassword());
             PreparedStatement stmt = conn.prepareStatement(query);
             ResultSet rs = stmt.executeQuery()) {
            
            while (rs.next()) {
                Map<String, Object> period = new HashMap<>();
                period.put("period", rs.getString("period"));
                period.put("revenue", rs.getDouble("revenue"));
                revenues.add(period);
            }
        }
        
        return revenues;
    }
    
    private List<Map<String, Object>> getRoutePerformanceFromDB() throws SQLException {
        List<Map<String, Object>> performances = new ArrayList<>();
        
        String query = 
            "SELECT " +
            "   r.Source + ' â†’ ' + r.Destination as route, " +
            "   r.BasePrice, " +
            "   COUNT(b.BookingID) as bookings, " +
            "   COALESCE(SUM(p.Amount), 0) as revenue, " +
            "   (COUNT(b.BookingID) * 100.0 / NULLIF((" +
            "       SELECT COUNT(*) FROM Seat s2 " +
            "       INNER JOIN Schedule sc2 ON s2.ScheduleID = sc2.ScheduleID " +
            "       WHERE sc2.RouteID = r.RouteID" +
            "   ), 0)) as occupancyRate " +
            "FROM Route r " +
            "LEFT JOIN Schedule s ON r.RouteID = s.RouteID " +
            "LEFT JOIN Booking b ON s.ScheduleID = b.ScheduleID AND b.Status = 'Confirmed' " +
            "LEFT JOIN Payment p ON b.PaymentID = p.PaymentID AND p.PaymentStatus = 'Completed' " +
            "WHERE r.IsActive = 1 " +
            "GROUP BY r.RouteID, r.Source, r.Destination, r.BasePrice " +
            "ORDER BY revenue DESC";
        
        try (Connection conn = DriverManager.getConnection(DatabaseConfig.getDbUrl(), 
                                                         DatabaseConfig.getDbUser(), 
                                                         DatabaseConfig.getDbPassword());
             PreparedStatement stmt = conn.prepareStatement(query);
             ResultSet rs = stmt.executeQuery()) {
            
            while (rs.next()) {
                Map<String, Object> performance = new HashMap<>();
                performance.put("route", rs.getString("route"));
                performance.put("basePrice", rs.getDouble("BasePrice"));
                performance.put("bookings", rs.getInt("bookings"));
                performance.put("revenue", rs.getDouble("revenue"));
                performance.put("occupancyRate", rs.getDouble("occupancyRate"));
                performances.add(performance);
            }
        }
        
        return performances;
    }
    
    private Map<String, Object> getRouteMetricsFromDB() throws SQLException {
        Map<String, Object> metrics = new HashMap<>();
        
        try (Connection conn = DriverManager.getConnection(DatabaseConfig.getDbUrl(), 
                                                         DatabaseConfig.getDbUser(), 
                                                         DatabaseConfig.getDbPassword())) {
            
            // Total active routes
            String routesQuery = "SELECT COUNT(*) as total FROM Route WHERE IsActive = 1";
            try (PreparedStatement stmt = conn.prepareStatement(routesQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    metrics.put("totalRoutes", rs.getInt("total"));
                }
            }
            
            // Total active schedules
            String schedulesQuery = "SELECT COUNT(*) as total FROM Schedule WHERE IsActive = 1";
            try (PreparedStatement stmt = conn.prepareStatement(schedulesQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    metrics.put("totalSchedules", rs.getInt("total"));
                }
            }
            
            // Average occupancy rate (simplified)
            String occupancyQuery = 
                "SELECT AVG(CAST(s.Availability AS INT)) * 100 as avgOccupancy " +
                "FROM Seat s " +
                "INNER JOIN Schedule sc ON s.ScheduleID = sc.ScheduleID " +
                "WHERE sc.Date >= GETDATE()";
            try (PreparedStatement stmt = conn.prepareStatement(occupancyQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    metrics.put("avgOccupancy", String.format("%.1f", 100 - rs.getDouble("avgOccupancy")));
                }
            }
            
            // Get popular class
            String classQuery = 
                "SELECT TOP 1 s.Class, COUNT(*) as count " +
                "FROM Booking b " +
                "INNER JOIN Reservation res ON b.ReservationID = res.ReservationID " +
                "INNER JOIN Schedule s ON res.ScheduleID = s.ScheduleID " +
                "WHERE b.Status = 'Confirmed' " +
                "GROUP BY s.Class " +
                "ORDER BY count DESC";
            try (PreparedStatement stmt = conn.prepareStatement(classQuery);
                 ResultSet rs = stmt.executeQuery()) {
                if (rs.next()) {
                    metrics.put("popularClass", rs.getString("Class"));
                }
            }
            
            // Calculate averages
            List<Map<String, Object>> performances = getRoutePerformanceFromDB();
            if (!performances.isEmpty()) {
                double totalBookings = 0;
                double maxOccupancy = 0;
                double minOccupancy = 100;
                double totalRevenue = 0;
                
                for (Map<String, Object> route : performances) {
                    int bookings = (int) route.get("bookings");
                    double occupancy = (double) route.get("occupancyRate");
                    double revenue = (double) route.get("revenue");
                    
                    totalBookings += bookings;
                    totalRevenue += revenue;
                    
                    if (occupancy > maxOccupancy) maxOccupancy = occupancy;
                    if (occupancy < minOccupancy) minOccupancy = occupancy;
                }
                
                metrics.put("avgBookings", totalBookings / performances.size());
                metrics.put("maxOccupancy", String.format("%.1f", maxOccupancy));
                metrics.put("minOccupancy", String.format("%.1f", minOccupancy));
                metrics.put("totalRevenue", totalRevenue);
            } else {
                metrics.put("avgBookings", 0);
                metrics.put("maxOccupancy", "0.0");
                metrics.put("minOccupancy", "0.0");
                metrics.put("totalRevenue", 0);
            }
        }
        
        return metrics;
    }

    // ==================== HELPER METHODS ====================

    private String getPerformanceStars(double occupancyRate) {
        if (occupancyRate >= 90) return "â­â­â­â­â­";
        else if (occupancyRate >= 80) return "â­â­â­â­";
        else if (occupancyRate >= 70) return "â­â­â­";
        else if (occupancyRate >= 60) return "â­â­";
        else return "â­";
    }

    private String getRankEmoji(int rank) {
        switch (rank) {
            case 1: return "ğŸ¥‡";
            case 2: return "ğŸ¥ˆ";
            case 3: return "ğŸ¥‰";
            default: return "   ";
        }
    }
    
    private String formatCurrency(double amount) {
        return String.format("%,.2f", amount);
    }

    private void exportReport() {
        if (reportArea.getText().isEmpty()) {
            showError("Please generate a report first");
            return;
        }
        
        Alert confirmation = new Alert(Alert.AlertType.INFORMATION);
        confirmation.setTitle("Export Report");
        confirmation.setHeaderText("Report Export");
        confirmation.setContentText("Report export functionality will be implemented in the next version.\n\n" +
                                  "For now, you can:\n" +
                                  "1. Copy the report text\n" +
                                  "2. Save it as a text file\n" +
                                  "3. Print the report");
        
        confirmation.showAndWait();
    }

    private void handleBack() {
        try {
            Stage currentStage = (Stage) backButton.getScene().getWindow();
            AdminDashboardController.show(currentStage, currentUsername, currentAdmin);
        } catch (Exception e) {
            showError("Failed to go back: " + e.getMessage());
        }
    }

    private void showError(String message) {
        showAlert("Error", message, Alert.AlertType.ERROR);
    }

    private void showSuccess(String message) {
        showAlert("Success", message, Alert.AlertType.INFORMATION);
    }

    private void showAlert(String title, String message, Alert.AlertType type) {
        Platform.runLater(() -> {
            Alert alert = new Alert(type);
            alert.setTitle(title);
            alert.setHeaderText(null);
            alert.setContentText(message);
            alert.showAndWait();
        });
    }

    private static void showErrorAlert(String message) {
        Platform.runLater(() -> {
            Alert alert = new Alert(Alert.AlertType.ERROR);
            alert.setTitle("Error");
            alert.setHeaderText(null);
            alert.setContentText(message);
            alert.showAndWait();
        });
    }
}